// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Provides a Mailgun App resource. This can be used to
 * create and manage applications on Mailgun.
 *
 * After DNS records are set, domain verification should be triggered manually using [PUT /domains/\<domain\>/verify](https://documentation.mailgun.com/en/latest/api-domains.html#domains)
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as mailgun from "@pulumi/mailgun";
 *
 * // Create a new Mailgun domain
 * const _default = new mailgun.Domain("default", {
 *     name: "test.example.com",
 *     region: "us",
 *     spamAction: "disabled",
 *     smtpPassword: "supersecretpassword1234",
 *     dkimKeySize: 1024,
 * });
 * ```
 *
 * Here's an example using the Cloudflare provider. Bear in mind that the solution below requires the Cloudflare provider to be included in your project. Also, the Mailgun provider isn't associated with Cloudflare, and other Terraform providers that can control DNS may require a slightly different implementation.
 *
 * For detailed setup instructions, see Mailgun's [Domain Verification Setup Guide](https://help.mailgun.com/hc/en-us/articles/32884702360603-Domain-Verification-Setup-Guide) or the [Cloudflare DNS Setup Guide](https://help.mailgun.com/hc/en-us/articles/15585722150299-Cloudflare-DNS-Setup-Guide).
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as cloudflare from "@pulumi/cloudflare";
 * import * as std from "@pulumi/std";
 *
 * // Use receiving/sending set attributes to create DNS entries
 * // TTL is set to 300 seconds (5 minutes) for faster updates as recommended by Mailgun
 * // You can adjust the TTL to your desired value
 * const defaultReceiving: cloudflare.index.DnsRecord[] = [];
 * for (const range of Object.entries(.reduce((__obj, record) => ({ ...__obj, [record.id]: {
 *     type: record.recordType,
 *     value: record.value,
 *     priority: record.priority,
 * } }))).map(([k, v]) => ({key: k, value: v}))) {
 *     defaultReceiving.push(new cloudflare.index.DnsRecord(`default_receiving-${range.key}`, {
 *         zoneId: zoneId,
 *         name: domain,
 *         type: range.value.type,
 *         content: range.value.value,
 *         priority: range.value.priority,
 *         ttl: 300,
 *     }));
 * }
 * const defaultSending: cloudflare.index.DnsRecord[] = [];
 * for (const range of Object.entries(.reduce((__obj, record) => ({ ...__obj, [record.id]: {
 *     name: record.name,
 *     type: record.recordType,
 *     value: record.value,
 * } }))).map(([k, v]) => ({key: k, value: v}))) {
 *     defaultSending.push(new cloudflare.index.DnsRecord(`default_sending-${range.key}`, {
 *         zoneId: zoneId,
 *         name: range.value.name,
 *         type: range.value.type,
 *         content: range.value.value,
 *         ttl: 300,
 *     }));
 * }
 * // Create MX records pointing to Mailgun
 * // Use "@" for name if using the root domain, or the subdomain name if using a subdomain
 * const mxRecords: cloudflare.index.DnsRecord[] = [];
 * for (const range = {value: 0}; range.value < std.index.toset({
 *     input: [
 *         "mxa.mailgun.org",
 *         "mxb.mailgun.org",
 *     ],
 * }).result; range.value++) {
 *     mxRecords.push(new cloudflare.index.DnsRecord(`mx_records-${range.value}`, {
 *         zoneId: zoneId,
 *         name: "@",
 *         type: "MX",
 *         content: range.value,
 *         priority: 10,
 *         ttl: 300,
 *     }));
 * }
 * ```
 */
export class Domain extends pulumi.CustomResource {
    /**
     * Get an existing Domain resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DomainState, opts?: pulumi.CustomResourceOptions): Domain {
        return new Domain(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'mailgun:index/domain:Domain';

    /**
     * Returns true if the given object is an instance of Domain.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Domain {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Domain.__pulumiType;
    }

    /**
     * (Enum: `yes` or `no`) The click tracking settings for the domain. Default: `no`
     */
    declare public readonly clickTracking: pulumi.Output<boolean | undefined>;
    /**
     * The length of your domain’s generated DKIM key. Default value is `1024`.
     */
    declare public readonly dkimKeySize: pulumi.Output<number | undefined>;
    /**
     * The name of your DKIM selector if you want to specify it whereas MailGun will make it's own choice.
     */
    declare public readonly dkimSelector: pulumi.Output<string | undefined>;
    /**
     * If set to true, the domain will be the DKIM authority for itself even if the root domain is registered on the same mailgun account. If set to false, the domain will have the same DKIM authority as the root domain registered on the same mailgun account. The default is `false`.
     */
    declare public readonly forceDkimAuthority: pulumi.Output<boolean | undefined>;
    /**
     * The domain to add to Mailgun
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * (Enum: `yes` or `no`) The open tracking settings for the domain. Default: `no`
     */
    declare public readonly openTracking: pulumi.Output<boolean | undefined>;
    /**
     * A list of DNS records for receiving validation.  **Deprecated** Use `receivingRecordsSet` instead.
     *
     * @deprecated Use `receivingRecordsSet` instead.
     */
    declare public /*out*/ readonly receivingRecords: pulumi.Output<outputs.DomainReceivingRecord[]>;
    /**
     * A set of DNS records for receiving validation.
     */
    declare public /*out*/ readonly receivingRecordsSets: pulumi.Output<outputs.DomainReceivingRecordsSet[]>;
    /**
     * The region where domain will be created. Default value is `us`.
     */
    declare public readonly region: pulumi.Output<string | undefined>;
    /**
     * A list of DNS records for sending validation. **Deprecated** Use `sendingRecordsSet` instead.
     *
     * @deprecated Use `sendingRecordsSet` instead.
     */
    declare public /*out*/ readonly sendingRecords: pulumi.Output<outputs.DomainSendingRecord[]>;
    /**
     * A set of DNS records for sending validation.
     */
    declare public /*out*/ readonly sendingRecordsSets: pulumi.Output<outputs.DomainSendingRecordsSet[]>;
    /**
     * The login email for the SMTP server.
     */
    declare public /*out*/ readonly smtpLogin: pulumi.Output<string>;
    /**
     * Password for SMTP authentication
     */
    declare public readonly smtpPassword: pulumi.Output<string | undefined>;
    /**
     * `disabled` or `tag` Disable, no spam
     * filtering will occur for inbound messages. Tag, messages
     * will be tagged with a spam header. Default value is `disabled`.
     */
    declare public readonly spamAction: pulumi.Output<string | undefined>;
    /**
     * If true Mailgun manages DKIM key generation and DNS record configuration automatically. Default: `false`
     */
    declare public readonly useAutomaticSenderSecurity: pulumi.Output<boolean | undefined>;
    /**
     * (`http` or `https`) The tracking web scheme. Default: `http`
     */
    declare public readonly webScheme: pulumi.Output<string | undefined>;
    /**
     * Boolean that determines whether
     * the domain will accept email for sub-domains.
     */
    declare public readonly wildcard: pulumi.Output<boolean | undefined>;

    /**
     * Create a Domain resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: DomainArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DomainArgs | DomainState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DomainState | undefined;
            resourceInputs["clickTracking"] = state?.clickTracking;
            resourceInputs["dkimKeySize"] = state?.dkimKeySize;
            resourceInputs["dkimSelector"] = state?.dkimSelector;
            resourceInputs["forceDkimAuthority"] = state?.forceDkimAuthority;
            resourceInputs["name"] = state?.name;
            resourceInputs["openTracking"] = state?.openTracking;
            resourceInputs["receivingRecords"] = state?.receivingRecords;
            resourceInputs["receivingRecordsSets"] = state?.receivingRecordsSets;
            resourceInputs["region"] = state?.region;
            resourceInputs["sendingRecords"] = state?.sendingRecords;
            resourceInputs["sendingRecordsSets"] = state?.sendingRecordsSets;
            resourceInputs["smtpLogin"] = state?.smtpLogin;
            resourceInputs["smtpPassword"] = state?.smtpPassword;
            resourceInputs["spamAction"] = state?.spamAction;
            resourceInputs["useAutomaticSenderSecurity"] = state?.useAutomaticSenderSecurity;
            resourceInputs["webScheme"] = state?.webScheme;
            resourceInputs["wildcard"] = state?.wildcard;
        } else {
            const args = argsOrState as DomainArgs | undefined;
            resourceInputs["clickTracking"] = args?.clickTracking;
            resourceInputs["dkimKeySize"] = args?.dkimKeySize;
            resourceInputs["dkimSelector"] = args?.dkimSelector;
            resourceInputs["forceDkimAuthority"] = args?.forceDkimAuthority;
            resourceInputs["name"] = args?.name;
            resourceInputs["openTracking"] = args?.openTracking;
            resourceInputs["region"] = args?.region;
            resourceInputs["smtpPassword"] = args?.smtpPassword ? pulumi.secret(args.smtpPassword) : undefined;
            resourceInputs["spamAction"] = args?.spamAction;
            resourceInputs["useAutomaticSenderSecurity"] = args?.useAutomaticSenderSecurity;
            resourceInputs["webScheme"] = args?.webScheme;
            resourceInputs["wildcard"] = args?.wildcard;
            resourceInputs["receivingRecords"] = undefined /*out*/;
            resourceInputs["receivingRecordsSets"] = undefined /*out*/;
            resourceInputs["sendingRecords"] = undefined /*out*/;
            resourceInputs["sendingRecordsSets"] = undefined /*out*/;
            resourceInputs["smtpLogin"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["smtpPassword"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Domain.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Domain resources.
 */
export interface DomainState {
    /**
     * (Enum: `yes` or `no`) The click tracking settings for the domain. Default: `no`
     */
    clickTracking?: pulumi.Input<boolean>;
    /**
     * The length of your domain’s generated DKIM key. Default value is `1024`.
     */
    dkimKeySize?: pulumi.Input<number>;
    /**
     * The name of your DKIM selector if you want to specify it whereas MailGun will make it's own choice.
     */
    dkimSelector?: pulumi.Input<string>;
    /**
     * If set to true, the domain will be the DKIM authority for itself even if the root domain is registered on the same mailgun account. If set to false, the domain will have the same DKIM authority as the root domain registered on the same mailgun account. The default is `false`.
     */
    forceDkimAuthority?: pulumi.Input<boolean>;
    /**
     * The domain to add to Mailgun
     */
    name?: pulumi.Input<string>;
    /**
     * (Enum: `yes` or `no`) The open tracking settings for the domain. Default: `no`
     */
    openTracking?: pulumi.Input<boolean>;
    /**
     * A list of DNS records for receiving validation.  **Deprecated** Use `receivingRecordsSet` instead.
     *
     * @deprecated Use `receivingRecordsSet` instead.
     */
    receivingRecords?: pulumi.Input<pulumi.Input<inputs.DomainReceivingRecord>[]>;
    /**
     * A set of DNS records for receiving validation.
     */
    receivingRecordsSets?: pulumi.Input<pulumi.Input<inputs.DomainReceivingRecordsSet>[]>;
    /**
     * The region where domain will be created. Default value is `us`.
     */
    region?: pulumi.Input<string>;
    /**
     * A list of DNS records for sending validation. **Deprecated** Use `sendingRecordsSet` instead.
     *
     * @deprecated Use `sendingRecordsSet` instead.
     */
    sendingRecords?: pulumi.Input<pulumi.Input<inputs.DomainSendingRecord>[]>;
    /**
     * A set of DNS records for sending validation.
     */
    sendingRecordsSets?: pulumi.Input<pulumi.Input<inputs.DomainSendingRecordsSet>[]>;
    /**
     * The login email for the SMTP server.
     */
    smtpLogin?: pulumi.Input<string>;
    /**
     * Password for SMTP authentication
     */
    smtpPassword?: pulumi.Input<string>;
    /**
     * `disabled` or `tag` Disable, no spam
     * filtering will occur for inbound messages. Tag, messages
     * will be tagged with a spam header. Default value is `disabled`.
     */
    spamAction?: pulumi.Input<string>;
    /**
     * If true Mailgun manages DKIM key generation and DNS record configuration automatically. Default: `false`
     */
    useAutomaticSenderSecurity?: pulumi.Input<boolean>;
    /**
     * (`http` or `https`) The tracking web scheme. Default: `http`
     */
    webScheme?: pulumi.Input<string>;
    /**
     * Boolean that determines whether
     * the domain will accept email for sub-domains.
     */
    wildcard?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a Domain resource.
 */
export interface DomainArgs {
    /**
     * (Enum: `yes` or `no`) The click tracking settings for the domain. Default: `no`
     */
    clickTracking?: pulumi.Input<boolean>;
    /**
     * The length of your domain’s generated DKIM key. Default value is `1024`.
     */
    dkimKeySize?: pulumi.Input<number>;
    /**
     * The name of your DKIM selector if you want to specify it whereas MailGun will make it's own choice.
     */
    dkimSelector?: pulumi.Input<string>;
    /**
     * If set to true, the domain will be the DKIM authority for itself even if the root domain is registered on the same mailgun account. If set to false, the domain will have the same DKIM authority as the root domain registered on the same mailgun account. The default is `false`.
     */
    forceDkimAuthority?: pulumi.Input<boolean>;
    /**
     * The domain to add to Mailgun
     */
    name?: pulumi.Input<string>;
    /**
     * (Enum: `yes` or `no`) The open tracking settings for the domain. Default: `no`
     */
    openTracking?: pulumi.Input<boolean>;
    /**
     * The region where domain will be created. Default value is `us`.
     */
    region?: pulumi.Input<string>;
    /**
     * Password for SMTP authentication
     */
    smtpPassword?: pulumi.Input<string>;
    /**
     * `disabled` or `tag` Disable, no spam
     * filtering will occur for inbound messages. Tag, messages
     * will be tagged with a spam header. Default value is `disabled`.
     */
    spamAction?: pulumi.Input<string>;
    /**
     * If true Mailgun manages DKIM key generation and DNS record configuration automatically. Default: `false`
     */
    useAutomaticSenderSecurity?: pulumi.Input<boolean>;
    /**
     * (`http` or `https`) The tracking web scheme. Default: `http`
     */
    webScheme?: pulumi.Input<string>;
    /**
     * Boolean that determines whether
     * the domain will accept email for sub-domains.
     */
    wildcard?: pulumi.Input<boolean>;
}
